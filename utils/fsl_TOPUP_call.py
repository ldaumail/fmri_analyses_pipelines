#!/usr/bin/env python#prerequisites: fsl, pydicom, numpy,import subprocessimport sysimport argparseimport pydicomimport numpy as npparser = argparse.ArgumentParser()parser.add_argument("filename1", type=str,help="input NIFTI filename for the first EPI image")parser.add_argument("filename2", type=str,help="input NIFTI filename for the second EPI image, which should have a different phase encoding direction relative to filename1")parser.add_argument("angle1", type=float,help="angle in degrees of the PE direction relative to horizontal for filename1",default=0)parser.add_argument("angle2", type=float,help="angle in degrees of the PE direction relative to horizontal for filename2",default=180)parser.add_argument("-nvol","--volumenumber", type=int,help="volume number to use for topup (assuming 4D nifti file)",default=1,dest="nvol")parser.add_argument("-dcm","--dicom", type=str,help="the name of the dicom file to be used for calculation of the EPI band width and total acquisition time, passed into TOPUP for accurate scaling of the calculated B0 map.",default="default",dest="dicom_name")parser.add_argument("-x","--xtraIMcorrection", type=str,help="filename of an extra NIFTI image to which you want to apply the TOPUP correction calculated from the images above. It is assumed that this image has the same phase encoding as filename1.",default="NONE",dest="filename3")parser.add_argument("-v", "--verbose", help="display more header information", action="store_true")args = parser.parse_args()# read the EPI bandwidth from the dicom file if availableif (args.dicom_name != 'default'):    # set constants    wfs_ppm=3.5  #the water - fat shift in units of ppm (i.e. field strength independent)    larmor_freq = 42.58 #MHz/T    # read the DICOM header to find the water fat shift of the sequence    ds=pydicom.dcmread(args.dicom_name)    # extract particular fields for calculations    wfs_seq=float(ds['2001','1022'].value)  #in pixels    try:        field_strength=float(ds['0018','0087'].value)  #in Tesla    except:        field_strength=float(ds['2001','1085'].value)  #in Tesla    EPI_factor=float(ds['2001','1013'].value)   #scalar    nsl=float(ds['2001','1018'].value)  #scalar    try:        TR=float(ds.RepetitionTime) #in ms    except:        TR=ds['2005','1030'].value        TR=TR[0]    bw= larmor_freq * field_strength * wfs_ppm / wfs_seq    #Hz/T * T * null / pixel    trt=1000*wfs_seq / (larmor_freq * field_strength * wfs_ppm  * (EPI_factor+1)) * EPI_factor #in ms    if args.verbose:        print("\nfilename: " + args.dicom_name)        print("water fat shift = " + str(wfs_seq) + " pixels")        print("field strength = " + str(field_strength) + "T")        print("epi factor = " + str(EPI_factor))        print("calculated bandwidth = " + str(bw) + " Hz")        print("total read out time (per echo train) = " + str(trt) + " ms")        print("(trt) * (#of sl) = " + str(trt*nsl) + " ms")        print("TR = " + str(TR) + " ms\n")else:    trt=1000    #default total read out time is 1000 ms, which is arbitrary, but is what the fsl guide uses when you want a default (meaningless) valueimtypenum=args.nvol #this sets the volume number in the nifti file that will be analyzedfilename1=args.filename1filename2=args.filename2if args.verbose:    print("============================================================")    print(filename1 + " acquired at " + str(args.angle1) + " degrees")    print(filename2 + " acquired at " + str(args.angle2) + " degrees")    print("volume number to be used for TOPUP: " + str(imtypenum))    print("============================================================\n")x1=np.cos(args.angle1/180*np.pi) #convert angle 1 to its x and y components on the unit circiey1=np.sin(args.angle1/180*np.pi) #convert angle 1 to its x and y components on the unit circiex2=np.cos(args.angle2/180*np.pi) #convert angle 1 to its x and y components on the unit circiey2=np.sin(args.angle2/180*np.pi) #convert angle 1 to its x and y components on the unit circieprint(str(x1) + " " + str(y1) + " 0 " + str(trt/1000))print(str(x2) + " " + str(y2) + " 0 " + str(trt/1000))#parse out the dir of args.filename1filename1_parse = args.filename1.split("/")filename1_dir = '' # 2019.02.01filename1_isolated = filename1_parse[-1]filename1_isolated_parsed = filename1_isolated.split(".")topup_basename = filename1_isolated_parsed[0]newfilename = filename1_dir+topup_basename+"_topup"out1 = subprocess.check_output(["fslnvols",filename1])   #check the number of volumes in the images passednvols_fn1=int(out1[0:-1])    #note the minus one because we need strip off the new line characterout2 = subprocess.check_output(["fslnvols",filename2])   #check the number of volumes in the images passednvols_fn2=int(out2[0:-1])    #note the minus one because we need strip off the new line characterif args.verbose:    print("\n================================================================")    print("running fslmerge with the following parameters:\n")    print(" topup calculated data base name: " + newfilename)    print(" input filename 1: " + filename1 + "---> " + str(nvols_fn1) + " volumes")    print(" input filename 2: " + filename2 + "---> " + str(nvols_fn2) + " volumes")    print("================================================================\n")# verify that the number of slices is an even number (apparently required by topup)# file 1call_string=["fslsize",filename1]size_string = subprocess.check_output(call_string)dim1_index = size_string.find("dim1")dim2_index = size_string.find("dim2")dim3_index = size_string.find("dim3")dim4_index = size_string.find("dim4")dim1_sizestr = size_string[dim1_index+4:dim2_index]dim2_sizestr = size_string[dim2_index+4:dim3_index]dim3_sizestr = size_string[dim3_index+4:dim4_index]nrow = int(dim1_sizestr)ncol = int(dim2_sizestr)nsl = int(dim3_sizestr)isodd = nsl % 2if args.verbose:    print("\n" + filename1 + " properties:")    print("# of rows: " + str(nrow))    print("# of cols: " + str(ncol))    print("# of sl = " + str(nsl) + "\n")if isodd == 1:    print("WARNING: topup prefers an even number of slices (apparently.. don't ask me). Subtracting a slice to accomodate this.")    nsl_mod=nsl-3    new_filename1 = filename1 + "_topup_nsl"+str(nsl_mod)    call_string_list = ["fslroi",filename1,new_filename1,"0","-1","0","-1","0",str(nsl_mod),"0","-1"]    #string to be used to add one blank slice to the image.    subprocess.call(call_string_list)   #use string to execute fslroi on filename 1    filename1 = new_filename1   #replace the input filename with the new file created with the extra slice# file 2call_string=["fslsize",filename2]size_string = subprocess.check_output(call_string)dim1_index = size_string.find("dim1")dim2_index = size_string.find("dim2")dim3_index = size_string.find("dim3")dim4_index = size_string.find("dim4")dim1_sizestr = size_string[dim1_index+4:dim2_index]dim2_sizestr = size_string[dim2_index+4:dim3_index]dim3_sizestr = size_string[dim3_index+4:dim4_index]nrow = int(dim1_sizestr)ncol = int(dim2_sizestr)nsl = int(dim3_sizestr)isodd = nsl % 2if args.verbose:    print("\n" + filename2 + " properties:")    print("# of rows: " + str(nrow))    print("# of cols: " + str(ncol))    print("# of sl = " + str(nsl) + "\n")if isodd == 1:    print("WARNING: topup prefers an even number of slices (apparently.. don't ask me). Subtracting a slice to accomodate this.")    nsl_mod=nsl-3;    new_filename2 = filename2 + "_topup_nsl"+str(nsl_mod)    call_string_list = ["fslroi",filename2,new_filename2,"0","-1","0","-1","0",str(nsl_mod),"0","-1"]    #string to be used to add one blank slice to the image. Note that nsl used here actually indicates nsl+1 number of slices since indexing begins at 0    subprocess.call(call_string_list)   #use string to execute fslroi on filename 1    filename2 = new_filename2   #replace the input filename with the new file created with the extra slice#separate out the specified image volume from both input filesfilename1_b0 = filename1+"_topup_b0"filename2_b0 = filename2+"_topup_b0"call_string_list = ["fslroi",filename1,filename1_b0,str(imtypenum-1),"1"]    #string to be used to separate out the b=0 image from filename1subprocess.call(call_string_list)   #use string to execute fslroi on filename 1call_string_list = ["fslroi",filename2,filename2_b0,str(imtypenum-1),"1"]    #string to be used to separate out the b=0 image from filename2subprocess.call(call_string_list)   #use string to execute fslroi on filename 2#merge the two dti filesets into onemerged_filename = newfilename+"mergedb0"call_string_list = ["fslmerge","-t",merged_filename,filename1_b0,filename2_b0]    #build the list of strings that need to be passed to fslmergeprint("creating merged file with different PE images: "+merged_filename)subprocess.call(call_string_list)   #this is the line that calls fslmerge#create the text file by looping over all the volumes in each of the two DTI studiesout1 = subprocess.check_output(["fslnvols",filename1_b0])   #this needs to change to the merged file namenvols1=int(out1[0:-1])    #note the minus one because we need strip off the new line characterout2 = subprocess.check_output(["fslnvols",filename2_b0])   #this needs to change to the merged file namenvols2=int(out2[0:-1])    #note the minus one because we need strip off the new line charactertxtfilename = newfilename+"_acqparams.txt"if args.verbose:    print("number of b0 vols from filename1_b0 = ",nvols1)    print("number of b0 vols from filename2_b0 = ",nvols2)    print("topup text file name: "+txtfilename)topup_params_1 = str(x1) + " " + str(y1) + " 0 " + str(trt/1000) + "\n"topup_params_2 = str(x2) + " " + str(y2) + " 0 " + str(trt/1000) + "\n"F=open(txtfilename,"w");F.write(topup_params_1)F.write(topup_params_2)F.close()if args.verbose:    print(" topup parameters:\n" + topup_params_1 + topup_params_2)# run topupprint("running topup...")call_string_list = ["topup","--imain="+merged_filename,"--datain="+txtfilename,"--config=b02b0.cnf","--out="+newfilename,"--fout="+newfilename+"_fieldmap","-v"]    #build the list of strings that need to be passed to topupsubprocess.call(call_string_list)   #this is the line that calls topupprint("done.")# apply topupprint("applying topup...")call_string_list = ["applytopup","--imain="+filename1,"--datain="+txtfilename,"--inindex=1","--topup="+newfilename,"--out="+filename1+"_TUcorrected","--method=jac"]    #build the list of strings that need to be passed to topupprint('[%s]' % ', '.join(map(str, call_string_list)))subprocess.call(call_string_list)   #this is the line that calls topupprint("done.")# apply topup again if there is another image passed for correctionif (args.filename3 != 'NONE'):    if args.verbose:        print("\n================================================================")        print(" input filename 3: " + args.filename3)        print("================================================================\n")        print("applying topup...")    call_string_list = ["applytopup","--imain="+args.filename3,"--datain="+txtfilename,"--inindex=1","--topup="+newfilename,"--out="+args.filename3[0:-4]+"_TUcorrected","--method=jac"]    #build the list of strings that need to be passed to topup    if args.verbose:        print("calling....")        print('[%s]' % ', '.join(map(str, call_string_list)))    subprocess.call(call_string_list)   #this is the line that calls topup    if args.verbose:        print("done.")print('Done.')